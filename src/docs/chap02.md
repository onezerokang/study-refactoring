# chap02: 리팩터링 원칙

## 2.1 리팩터링 정의

리팩터링은 두루뭉실한 의미로 통용되곤 하지만 저자는 이 용어를 엄격하게 정의해야 더 유용하다고 생각한다.
‘리팩터링’이란 용어는 명사로도 동사로도 쓸 수 있다.

- **리팩터링**: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
    - 앞 장에서 본 **함수 추출하기**와 **조건부 로직을 다형성으로 바꾸기**처럼 이름 붙은 리팩터링 기법이 이 정의에 해당한다.
- **리팩터링(하다)**: [동사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 ‘리팩터링’이라 표현하고 있는데, 앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다. 리팩터링은 결국 동작을 보존하는 작은
단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

> 누군가 “리팩터링 하다가 코드가 깨져서 며칠이나 고생했다”라고 한다면, 십중팔구 리팩터링한 것이 아니다.

저자는 코드베이스를 정리하거 구조를 바꾸는 모든 작업을 재구성(restructuring)이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성 중 특수한 형태로 본다. 한 번에 바꿀 수 있는 작업을 수 많은 단계로 잘게
나눠서 작업하는 모습을 보면 비효율적이라 생각하기 쉽지만 오히려 작업을 더 빨리 처리할 수 있다. 단계들이 체계적으로 구성되어 있기도 하고, 디버깅하는 데 시간을 뻇기지 않기 때문이다.

리팩터링하기 전과 후의 코드 동작이 같아야 하는데 완전히 그렇지는 않다. 특히 **함수 선언 바꾸기**나 **함수 옮기기** 같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많다.

## 2.2 두 개의 모자

저자는 개발할 때 목적이 ‘기능 추가’냐, 아니면 ‘리팩터링’이냐를 명확히 구분해 작업한다.
‘기능 추가’모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.
반면 ‘리팩터링’ 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. 이때 테스트를 추가하지 않으며, 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.

## 2.3 리팩터링하는 이유

- **리팩터링하면 소프트웨어 설계가 좋아진다**
    - 하지 않으면 아키텍처가 썩기 쉽다.
        - 지저분한 코드는 아키텍처를 이해하는데 방해가 됨.
        - 아키텍처에 대한 이해 없이 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너짐
        - 코드가 더 지저분해져서 이해가 더 어려워짐.
        - 악순환
    - 중복 코드 제거는 설계 개선 작업에 중요한 한 축을 차지한다.
        - 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다.
- **리팩터링하면 소프트웨어를 이해하기 쉬워진다**
    - 리팩터링은 코드가 더 잘 읽히게 도와준다.
    - **기억할 필요가 잇는 것들을 최대한 코드에 담으려고 하면** 코드를 쉽게 읽을 수 있다.
- **리팩터링하면 버그를 쉽게 찾을 수 있다**
    - 코드 이해 쉬움 = 버그를 찾기 쉽다
    - 프로그램의 구조를 명확히 다듬으면 ‘이럴 것이다’라고 가정하던 점들이 분명하게 드러나고, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.
- **리팩터링하면 프로그래밍 속도를 높일 수 있다**
    - 지금까지 제시한 장점 압축 정리 -> 코드 개발 속도를 높일 수 있다.
    - 기능이 누적되더라도 코드베이스에서 헤매는 것이 아닌 기존에 작성한 코드를 최대한 활용할 수 있어 새 기능을 더 빨리 추가한다.
    - 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.
    - 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.

## 2.4 언제 리팩터링해야 할까?

- 저자는 한 시간 간격으로 리팩터링한다.
- **3의 법칙**
    - 처음에는 그냥 한다.
    - 비슷한 일을 두 번째로 하게되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
    - 비슷한 일을 세 번째 하게 되면 리팩터링한다.
- **준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
    - 코드 베이스에 기능을 새로 추가하기 직전에 리팩토링 한다.
    - 구조를 살짝 바꾸면 다른 작업을 하기 쉬워질 만한 부분을 찾는다.
    - 버그를 잡을 때도 오류를 일으키는 코드가 분산되어 있다면, 우선 한 곳으로 합치는 것이 작업하기에 훨씬 편하다.
- **이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
    - 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
    - 코드가 어느정도 이해되면 자잘한 세부 코드에 이해를 위한 리팩터링을 한다.
    - 변수를 적절한 이름으로 바꾸고, 긴 함수를 잘게 나눈다.
- **쓰레기 줍기 리팩터링**
    - 코드를 파악하던 중에 비효율적으로 처리하는 모습을 발견할 때가 있다.
    - 간단히 수정할 수 있다면 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남기고, 하던 일을 끝내고 나서 처리한다.
    - 리팩터링은 잘게 나누어서 하기에 중단해도 문제가 없다. 기존보다 조금만 더 낫게 하고 가는 것이다.
- **계획된 리팩터링과 수시로 하는 리팩터링**
    - 저자는 개발에 들어가기 전에 리팩터링 일정을 따로 빼지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다.
    - 리팩터링은 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다. 보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만, 잘 작성된 코드 역시 수 많은 리팩터링을 거쳐야 한다.
    - > 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자
      > _켄트 백
    - 그렇다고 해서 계획된 리팩터링이 무조건 나쁜 것은 아님.
        - 그동안 소홀했다면, 따로 시간을 내서 개선할 필요가 있음.
        - 그래도 기회가 될 때마다 하는 게 좋음
    - 버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언이 있음
        - 장점: 두 가지 활동을 구분해서 별개로 검토하고 승인
        - 필자는 완전히 동의하진 않음
            - 리팩터링은 기능 추가와 밀접하게 엮인 경우가 많기에 굳이 나누는 것은 시간 낭비일 수도 있다.
            - 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다.
- **오래 걸리는 리팩터링**
    - 리팩터링은 대 부분 몇 분 안에 끝나고, 길어야 몇 시간 정도.
    - 저자는 팀 전체가 몇 주 걸리는 대규모 리팩터링에 매달리는 데 회의적
    - 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적이라 생각함.
    - 누구든지 리팩터링 할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식.
    - 리팩터링이 코드를 깨트리지 않는다는 장점을 활용
    - 예컨대 라이브러리 교체할 때 기존 것과 새 것을 모두 포용하는 추상 인터페이스부터 마련.
        - 기존 코드가 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 쉽게 교체 가능
        - 이 전략을 추상화 갈아타기(Branch By Abstraction)라 한다.
- **코드 리뷰에 리팩터링 활용하기**
    - 리팩터링을 활용하기 전에는 코드를 읽고 이해한 뒤, 몇 가지 개선 사항 제시.
    - 지금은 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지부터 살펴봄
    - 쉽다면 실제로 리팩터링
    - 몇 변 반복하면 내가 떠올린 아이디어를 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있음.
    - 리팩터링은 개선한을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기에 도움이 됨.
- **관리자에게는 뭐라고 말해야 할까?**
    - 리팩터링의 중요성을 모르는 관리자에게는 “리팩터링한다고 말하지 말라”
    - 하극상이 아니다.
    - 개발자의 역할은 소프트웨어를 최대한 빨리 만드는 것이고 리팩터링은 빠르게 만드는 데 아주 효과적이다.
- **리팩터링하지 말아야 할 때**
    - 지저분한 코드를 발견하더라도 굳이 수정할 필요가 없다면 리팩터링 하지 않는다.
    - 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.
    - 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
    - 처음부터 새로 작성하는 게 쉬울 때도 리팩터링 하지 않는다.

## 2.5 리팩터링 시 고려할 문제

필자는 특정한 기술, 도구, 아키텍처를 내세울 때마다 항상 문제점을 찾는다.
무언가를 언제 적용할지 판단하려면 손익을 제대로 판단해야 한다.

- **새 기능 개발 속도 저하**
    - 리팩터링의 궁극적인 목적은 개발 속도 향상이다.
    - 아래는 저자가 리팩터링 하지 않는 상황
        - 직접 건드릴 일이 거의 없는 코드
        - 불편한 정도가 그리 심하지 않음
        - 어떻게 개선해야 할지 확실히 떠오르지 않음
    - 그래도 대부분은 리팩터링을 더 자주 하도록 노력해야 함.
    - 리팩터링은 코드 베이스를 예쁘게 꾸려고 하는 것이 아닌 경제적인 이유로 하는 것이다.
- **코드 소유권**
    - 리팩터링하다 보면 모듈의 내부뿐 아니라 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다.
    - 클라이언트가 사용하는 ‘공개된 인테페이스’의 경우 리팩터링 하기 어려울 수 있다.
    - 그렇다고 리팩터링을 할 수 없는 것은 아니다. 제약이 따를 뿐..
    - 예컨대 함수 이름을 변경할 때는 **함수 이름 바꾸기**를 적용하는 한편, 기존 함수도 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정한다. 인터페이스가 복잡해지지만 클라에 영향을 주지 않기
      위해서는 어쩔 수 없다.
    - 그래서 필자는 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대한다.
    - 함수 이름만 바꾸면 되는데 인터페이스가 복잡해지고 관리하는 것이 공수가 많이 듦.
- **브랜치**
    - 각 브랜치에서 작업하고 결과물이 쌓이면 master 브랜치에 통합해 공유하는 방식이 단점:
        - 독립 브랜치로 작업하는 기간이 길어질수록 병합이 어려워짐.
        - 수시로 master를 개인 브랜치로 rebase, merge 함.
        - 저자는 지속적 통합(CI), 또는 트렁크 기반 개발을 해야 한다고 함.
            - 하루에 최소 한 번은 마스터와 통합해서 머지의 복잡도를 낮춤
            - 이를 위해서는 거대한 기능을 잘게 쪼개고, 각 기능을 끌 수 있는 기능 토클을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 함.
            - CI는 리팩터링과 궁합이 좋음.
- **테스팅**
    - 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 함.
    - 실수를 하더라도 오류를 재빨리 잡아야 하는데 이렇게 하려면 테스트 스위트가 필요함.
    - 즉 리팩터링하기 위해서는 (대부분의 경우에) 자가 테스트 코드를 마련해야 함.
    - 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다.
- **레거시 코드**
    - 물려받는 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않음.
    - 레거시 시스템 파악 시 리팩터링이 굉장히 도움됨.
    - 만약 테스트가 없으면 테스트를 보강해야 하지만 까다로움
        - 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트할 수 있음.
    - 이런 경우 레거시 코드 활용 전략에 나온 지침을 충실히 따르자.
        - 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트 해야 한다
        - 틈새를 만들 때 리팩터링이 활용됨.
        - 테스트 없이 리팩터링을 해야하지만 쩔수..
        - 그래서 단번에 하기보다는 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력해야 함.
- **데이터베이스**
    - 잘 와닿지 않음으로 일단 생략(p.99)
    - 프라모드 사달게가 개발한
        - 진화형 데이터베이스 설계(evolutinary database design)와 데이터베이스 리팩터링 기법
            - 핵심: 커다란 변경을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합.
            - 예시:
                - 생략

## 2.6 리팩터링, 아키텍처 애그니(YAGNI)

리팩터링은 소프트 웨어 아키텍처를 바라보는 관점을 완전히 바꿈

- before: 선 설계 후 코딩
- after: 코딩 사이에 자연스레 리팩터링(설계 변경)

리팩터링은 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해줌.
코딩 전에 아키텍처를 확정지으면 막상 코딩할 때 잘 안될 때가 많음.
미리 일어나지도 않은 미래의 확장 확률을 고려하여 개발해도 실제로 그렇게 확장되지 않을 때도 많음.

그저 현재까지 파악한 요구사항을 해결하는 소프트웨어를 잘 설계해서 개발하고
진행하면서 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링 하는거임.

- 예시: *호출하는 측에서 항상 같은 값을 넘기는 매개변수는 목록에 넣지 않고, 추가해야 할 시점에 함수 매개변수화하기로 해결한다.*

이런식으로 설계하는 방식을 간결한 설계(simple design), 점진적 설계(incremental design), YAGNI(you aren’t going to need it)등으로 부른다.

- ’당장에 필요한 기능만으로 최대한 간결하게 만들라’는 뜻
- 필요할 것 같아서 미리 구현해둔 기능 상당수가 전혀 쓰이지 안헉나, 미래의 요구사항을 제대로 반여하지 못해 수정이 어려워지는 경우가 많음

YAGNI를 받아들인다고 해서 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아님.
미리 생각해두면 시간이 절약되는 경우도 있음.
다만 이제는 둘 사이의 균형점이 달라진 거임
저자는 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽에 훨씬 낫다고 생각하는 편
이러한 경향은 진화형 아키텍처(evolutinary architecture) 원칙이 발전하는 계기가 됨

## 2.7 리팩터링과 소프트웨어 개발 프로세스

2.5절을 읽었다면 팀이 따르는 실천법에 따라 리팩터링의 효과가 크게 달라진다는 사실 발견할 수 있음.
리팩터링이 퍼진 것도 XP에 도입되어서다.

리팩터링의 첫 번째 토대는 자가 테스트 코드다.
팀으로 개발하면서 리팩터링을 하려면 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다. 지속적 통합을 적극 권장하는 이유도 바로 이때문이다. 이를 적용하면 팀원 각자가 수행한 리팩터링 결과를
빠르게 동료와 공유할 수 있다.

자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘
이를 실천하면 YAGNI 설계 방식으로 개발을 진행할 수 있음.

## 2.8 리팩터링과 성능

저자는 소프트웨어를 이해하기 쉽게 만들기 위해 속도가 느려지는 방향으로 수정하는 경우가 많다.
**리팩터링하면 소프트웨어가 느려질수도 있지만 동시에 성능을 튜닝하기는 더 쉬워진다.**
하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.

- 저자가 경함한 빠른 소프트웨어를 작성하는 방법 세가지
    - 예산 분배(time budgeting) 방식:
        - 하드 리얼타임 시스템에서 많이 사용.
        - 설계를 여러 컴포넌트로 나눠 컴포넌트마다 자원(시간과 공간) 예산을 할당.
        - 심장 박동 조율기처럼 데이터가 늦게 도착하면 안 되는 시스템에서 이러한 점이 굉장히 중요함.
    - 끊임없이 관심 기울이기
        - 직관적이어서 흔히 사용하지만 실제 효과는 변변치 않음.
        - 성능 개선 위해 코드 수정하면 다루기 어려운 형태로 변하기 쉽고 개발이 더뎌짐.
        - 각각의 개선은 프로그램의 특정 동작에만 관련될 뿐, 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할때도 많다.
        - **성능을 개선하기 위한 방법을 고민할 때 섣불리 추측하지 말고 성능을 측정하는 것이 가장 중요하다. 그러면 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다**
        - 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.
            - 따라서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없다.
    - 90%의 시간은 낭비
        - 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.
        - 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.
            - 프로파일러로 프로그램을 분석하여 시간, 공간을 많이 잡아먹는 지점을 알아낸다.
            - 많이 잡아먹는 지점을 집중적으로 최적화하면 적은 노력으로 큰 효과
            - 이때도 작은 단계로 나눠서 진행하고, 테스트하고, 프로파일러를 다시 실행해봐야 함.
                - 성능이 개선되지 않았다면 롤백..
                - 만족하는 성능이 나올 때까지

## 2.9 리팩터링의 유래

- 정확한 유래는 찾을 수 없음.
- 저자는 리팩터링은 개발 프로세스 전반의 핵심 요소라고 주장함.
- 위드 커닝햄과 켄트 백은 생산성을 높이는데 리팩터링의 역할이 크다는 사실을 깨닫고, 실전 프로젝트에 활용함

## 2.10 리팩터링의 자동화

- 자동 리팩터링을 지원하는 도구가 등장하면서 더 안정적으로 리팩터링을 할 수 있게 됨.
- 자동 리팩터링 기능은 <리팩터링 브라우저>에서 최초로 등장하였고, 젯브레인즈에서 인텔리제이 IDEA를 출시할 때 내세운 대표 기능 중 하나였다.
- 현재는 자동 리팩터링이 흔해짐.
- 자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌 구문 트리(syntax tree)로 해석해서 다뤄야 함. IDE는 리팩터링뿐만 아니라 코드 탐색과 린팅을 비롯한 다양한 기능을 구현하는 데 구문 트리를
  활용함.

## 2.11 더 알고 싶다면

- <리팩터링 워크북, 윌리엄 웨이크>: 리팩터링 연습에 주력한 책
- <패턴을 활용한 리팩터링, 조슈아 케리에프스키>: 디자인 패턴에서 핵심적인 패턴을 골라, 코드를 그 패턴대로 재구성하기 위해 리팩터링하는 방법을 다룬 책
- <레거시 코드 활용 전략, 마이클 페더스>: 테스트 커버리지가 낮은 오래된 코드베이스를 리팩터링하는 방법을 다룬 책
- <리팩토링 데이터베이스, 스캇 엠블러 & 프라모드 사달게>
- <리팩토링 HTML, 엘리엇 러스티 해롤드>