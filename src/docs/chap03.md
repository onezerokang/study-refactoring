# 리팩터링 3장: 코드에서 나는 악취

- 리팩터링을 언제 시작하고 언제 그만할지 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지 않게 중요하다.
- 저자는 리팩터링이 필요한 코드들에 일정한 패턴이 있다는 사실을 발견했고, 리팩터링을 할 시점을 설명하는데 ‘냄새’란 표현을 사용했다.
- 3장(혹은 부록B)를 읽고 코드가 풍기는 악취를 찾고, 6~12장에서 제시하는 리팩터링 기법을 적용하여 냄새를 제거할 수 있을지 생각해보자.

## 3.1 기이한 이름(Mysterious Name)

- 코드는 단순하고 명료해야 하며, 이를 위해서는 ‘이름’을 잘 짓는게 중요하다.
    - 함수, 모듈, 변수, 클래스 등은 이름만 보고 무엇을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
    - 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.
- 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다.
    - 마땅한 이름이 떠오르지 않는다면 설계에 근본적인 문제가 숨어 있을 가능성이 높다.
    - 그래서 혼란스러운 이름을 잘 정리하다보면 코드가 훨씬 간결해질 때가 많다.

## 3.2 중복 코드(Duplicated Code)

- 중복 코드의 문제
    - 코드가 중복되면 각각을 볼 때마다 서로 차이점이 없는지 주의 깊게 살펴봐야 하는 부담 발생
    - 수정이 필요하면 비슷한 코드들도 모두 살펴보고 적절히 수정 필요
- 리팩터링 예시
    - 한 클래스에 딸린 두 메서드가 똑같은 표현식 사용하는 경우
        - **함수 추출하기**로 양쪽 모두 추출된 메서드를 호출하게 변경
    - 코드가 비슷한데 완전 같진 않은 경우
        - **문장 슬라이드하기**로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있을지 살펴보기
    - 같은 부모를 갖는 서브 클래스에 코드가 중복된 경우
        - **메서드 올리기**를 적용해 부모로 옮긴다.

## 3.3 긴 함수(Long Function)

- 저자 경험상 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성됨
    - 얼핏 보면 연산하는 부분이 하나도 없어 보임
        - 코드가 끝없이 위임하는 방식으로 작성되어 있음
    - 이런 짧은 함수 중요함
        - 간접 호출(indirection)의 효과
        - 코드를 이해하고, 공유하고 쉬워진다는 장점은 함수를 짧게 구성할 때 나온다.
- 물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 여전히 부담됨.
    - (내가 고민하던 문제, 너무 짧게 나누면 여러 곳을 왔다 갔다 해야 함)
    - 함수 이름을 잘 지으면 본문 코드를 볼 이유가 사라진다.
    - 이름을 잘짓기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다.
        - 이름이 애매하면 책임이 명확하지 않음
    - 주석을 달아야 할 부분을 무조건 함수로 만든다.
    - 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.
- 함수를짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다.
- 함수가 매개변수와 임시 변수를 너무 많이 사용하면 추출 작업에 방해가 된다.
    - 매개변수가 많아지면 리팩터링 전보다 난해해질 수 있음.
    - **임시 변수를 질의 함수로 바꾸기** -> 임시 변수의 수 낮추기
    - **매개변수 객체 만들기** & **객체 통째로 넘기기** -> 매개변수의 수를 줄이기
- 여전히 임시 변수와 매개변수가 너무 많다면 **함수를 명령으로 바꾸기**를 고려해보자.
- 추출할 코드 덩어리를 찾는법
    - 보통 코드만으로 이해가 어려운 코드에 주석이 달림
    - 따라서 주석이 설명하는 코드를 추출하고, 함수 이름을 주석 내용을 토대로 짓는다.
- 조건문이나 반복문도 추출 대상의 실마리를 제공함
    - 조건문 -> **조건문 분해하기**
    - 거대한 switch -> case문마다 **함수 추출하기**
    - 같은 조건으로 나뉘는 switch 문이 여러개 -> **조건문을 다형성으로 바꾸기**
    - 이름 짓기 어려운 반복문(여러 책임을 갖고 있을 수 있음) -> **반복문 쪼개기**

## 3.4 긴 매개변수 목록(Long Parameter List)

- 매개변수 목록이 길어지면 이해가 어려워짐
- 예시
    - 다른 매개변수에서 값을 얻어올 수 있는 매개변수 -> **매개변수를 질의 함수로 바꾸기**
    - 사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 -> **객체 통째로 넘기기**
    - 항상 함께 전달되는 매개변수들은 -> **매개변수 객체 만들기**
    - 함수의 동작 방식을 정의하는 플래그 역할의 매개변수는 -> **플래그 인수 제거하기**
    - 여러개의 함수가 특정 매개변수를 공통으로 사용하고 있다면 -> 여러 함수를 클래스로 묶기

## 3.5 전역 데이터(Global Data)

- 전역변수는 코드베이스 어디에서든 접근할 수 있고, 값을 누가 바꿨는지 찾아낼 메커니즘이 없음.
- **변수 캡슐화하기** 리팩터링 적용
- 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있음.

## 3.6 가변 데이터(Mutable Data)

- 데이터 변경 -> 사이드 이펙트 -> 버그
- 함수형 프로그래밍에서는 데이터는 불변하고, 변경하려면 원본은 그대로 둔 채 복사본을 만들어서 반환한다는 기본 개념을 기본으로 삼고 있음.
- **변수 캡슐화하기** -> 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거 코드 개선이 쉬움
- 하나의 변수가 여러 용도로 사용되기 위해 값을 갱신하는 경우라면 **변수 쪼개기**로 용도별로 독립 변수에 저장하여 값 갱신이 문제를 일으킬 여지를 없앤다.
- 갱신 로직은 다른 코드와 떨어뜨려 놓는게 좋음
    - **문장 슬라이드하기**와 **함수 추출하기**를 이용해 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.
- API를 만들 때는 **질의 함수와 변경 함수 분리하기**를 활용해 꼭 필요한 경우가 아니라면 부작용 있는 코드를 호출할 수 없게 한다.
- **세터 제거하기**도 적용한다.
- **파생 변수를 질의 함수 바꾸기**에 식초 농축액을 섞어서 코드 전체에 뿌려준다.
- 변수의 유효범위가 몇 줄뿐이라면 가변 데이터라 해도 문제 적음
- 유효범위가 넓어지면 위험 커짐
- **여러 함수를 클래스로 묶기**나 **여러 함수를 변환 함수로 묶기**를 활용해서 변수를 갱신하는 코드들의 유효 범위를 제한한다.
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면 **참조를 값으로 바꾸기**를 적용해, 내부 필드를 직접 수정하지 말고 구조체를 통쨰로 교체한다.

## 3.7 뒤엉킨 변경

- 정의:
    - 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다.
    - 하나의 모듈이 서로 다른 이유들로 인해 변경되는 일이 많을 때
    - ex. 지원해야 할 DB가 추가되면서 금융 상품을 처리하는 모듈에서 변경이 발생함.
- 리팩터링 기법:
    - 맥락별 분리가 필요하다.
    - **단계 쪼개기**: DB에서 데이터를 가져오는 단계와 금융 상품을 처리하는 로직을 분리한다.
    - **함수 옮기기**:
    - **함수 추출하기**:
    - **클래스 추출하기**:

## 3.8 산탄총 수술(Shotgun Surgery)

- 정의
    - 응집도가 낮은 상태
    - 코드를 변경할 때 자잘하게 수정해야 하는 클래스가 많을 때
- 리팩터링 기법:
    - 맥락별 모음이 필요하다.
    - 함께 변경되는 대상을 **함수 옮기기**와 **필드 옮기기**로 한 모듈으로 묶는다.
    - 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**
    - 데이터 구조를 변환하거나 보강하는 함수들에는 **여러 함수를 변환함수로 묶기**를 적용
    - 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 **단계 쪼개기**
    - 어설프게 분리된 로직을 **함수 인라인하기**나 **클래스 인라인하기**로 합치기

## 3.9 기능 편애(Feature Envy)

- 정의
    - 모듈화 시에는 모듈 내의 상호작용을 늘리고, 영역 사이의 상호작용을 줄이는데 주력
    - 어떤 함수가 다른 모듈의 함수나 데이터와 상호작용 할 일이 많을 때 풍기는 냄새
- 리팩터링 기법
    - **함수 옮기기**로 해당 모듈로 이동
    - 함수가 사용하는 모듈이 다양하다면 가장 많은 데이터를 포함한 모듈로 옮긴다.
    - **함수 추출하기**로 함수를 쪼갠 후 각각 적합한 모듈로 옮기면 쉽게 해결될 수도 있다.

## 3.10 데이터 뭉치(Data Clumps)

- 정의
    - 항상 같이 다니는 데이터들
    - 값 하나를 삭제했을 때 나머지 데이터만으로 의미가 없다면 데이터 뭉치다.
- 리팩터링 기법
    - 데이터 항목이 여러 곳에서 함께 뭉쳐다닌다면 **클래스 추출하기**로 묶어준다.
    - **매개변수 객체 만들기**나 **객체 통쨰로 넘기기**를 적용해 매개변수 수를 줄인다.

## 3.11 기본형 집착(Primitive Obsession)

- 정의
    - 돈, 전화번호, 이메일 같은 규칙을 갖은 데이터의 타입을 전부 기본형으로 사용, 계산하는 것
- 리팩터링 기법
    - **기본형을 객체로 바꾸기**: 의미 있고 규칙을 담은 객체로 탈바꿈
    - 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 **타입 코드를 서브 클래스로 바꾸기**와 **조건부 로직을 다형성으로 바꾸기**를 차례로 적용한다.

## 3.12 반복되는 switch문(Repeated Switches)

- 정의
    - 똑같은 조건부 로직(switch, 길게 늘어진 if else)이 여러 곳에 반복할 경우
    - 조건절을 하나 추가할 때마다 다른 switch문을 모두 바꿔서 수정해야 한다.
    - 중복되지 않는 경우 무조건 바꿔야 하는 것은 아니다.
- 리팩터링 기법
    - **조건부 로직을 다형성으로 바꾸기**

## 3.13 반복문(Loops)

- 현재는 일급 함수(first-class function)을 지원한느 경우가 많아짐
- **반복문을 파이프라인으로 바꾸기**를 적용해 반복문 제거하자.
- filter, map 같은 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는지 쉽게 파악 가능

## 3.14 성의 없는 요소(Lazy Element)

- 본문 코드를 그대로 쓰는 것과 진배 없는 함수
- 실질적으로 메서드가 하나뿐인 클래스
- **함수 인라인하기**, **클래스 인라인하기**로 처리한다.
- 상속을 사용했다면 **계층 합치기**
- 의문: Layer를 구분하기 위해 성의 없는 요소를 사용하는 경우는 허용해줘도 된다고 생각한다.

## 3.15 추측성 일반화

- 정의
    - 미래를 대비해 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성한 코드
    - 테스트 코드에서만 사용하는 함수나 클래스에서 흔히 볼 수 있다.
- 기법
    - 하는 일이 거의 없는 추상 클래스 -> **계층 합치기**
    - 쓸데없이 위임하는 코드 ->  **함수 인라인하기** or **클래스 인라인하기**
    - 본문에서 사용되지 않은 매개변수 -> **함수 선언 바꾸기**
    - **죽은 코드 제거하기**

## 3.16 임시 필드

- 정의
    - 특정 상황에서만 값이 설정되는 필드
    - 객체를 사용하는 입장에서 쓰이지 않는 것처럼 보이는 필드의 존재 이유를 파악하기 어렵다
- 기법
    - **클래스 추출하기**로 적절한 곳에 배치한다.
    - **함수 옮기기**로 임시 필드와 관련된 코드를 모조리 새 클래스로 몰아넣는다.
    - 임시 필드 유효성 체크 조건부 로직을 **특이 케이스 추가하기**로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거한다.

## 3.17 메시지 체인

- 정의
    - 클라이언트가 객체를 통해 객체를 얻고, 얻은 객체에서 또 다른 객체를 요청하는 식
    - ex. aPerson.getDepartment().getManager().getName();
    - 클라이언트가 객체 내비게이션 구조에 종속되어, 내비게이션 중간 단계를 수정하면 클라이언트도 수정 발생
- 기법
    - **위임 숨기기**
    - **함수 추출하기**
    - **함수 옮기기**
    - 최종 결과 객체의 쓰임새를 확인하고 체인을 숨기자.
    - ex. aPerson.getManagerName();

## 3.18 중개자

- 정의
    - 지나친 책임 위임
    - ex. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있는 경우
- 기법
    - **중개자 제거하기**로 실제 일을 하는 객체와 직접 소통하게 한다.
    - 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자(**함수 인라인하기**)

## 3.19 내부자 거래

- 정의
  - 
- 기법
  - 

## 3.20 거대한 클래스

- 정의
    - 한 클래스가 너무 많은 일을 하려고 함 -> 필드 많아짐 -> 중복 코드가 생기기 쉬움
        - 같은 컴포넌트에 모아두는 것이 합당해보이는 필드를 모아둔다.
    - 클래스 내에서 중복이 많은 경우에는 공통 로직을 메서드로 뽑는다.
- 기법
    - **클래스 추출하기** -> 필드들 일부로 따로 묶는다.
    - 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 것이 좋은 경우
        - -> **슈퍼클래스 추출하기**
        - -> **타입 코드를 서브클래스로 바꾸기**
    - 클라이언트들이 클래스의 특정 기능 그룹만 이용하고 있다면 클래스를 분리한다.

## 3.21 서로 다른 인터페이스의 대안 클래스들

- 정의
    - 클래스의 장점은 언제든 다른 클래스로 교체 가능 -> 인터페이스가 같아야 함.
- 기법
    - **함수 선언 바꾸기**로 메서드 시그니처를 일치시킨다.
    - 부족하면 **함수 옮기기**로 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
    - 대안 크래스들 사이에 중복이 생기면 **슈퍼클래스 추출하기** 적용 고밈ㄴ

## 3.22 데이터 클래스

- 정의
    - 데이터 필드가 게터/세터 메서드로만 구성된 클래스
    - 다른 클래스가 함부로 다루지 않게 public 필드가 있다면 **레코드 캡슐화하기**
    - 변경하면 안되는 필드는 **세터 제거하기**
- 기법

## 3.23 상속 포기

- 정의
  - 
- 기법

## 3.24 주석

- 정의
    - 주석은 악취가 아닌 향기를 입힌다.
    - 다만 잘못 작성된 코드 악취를 숨기기 위해 주석을 장황하게 작성하는 경우가 있다.
- 기법
    - 특정 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**를 적용해본다.
    - 이미 추출된 함수에도 여전히 설명이 필요하다면 **함수 이름바꾸기**로 함수 이름을 바꿔본다.
    - 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 **어서션 추가하기**가 대기하고 있다.

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

- 뭘할지 모를 떄라면 주석을 달아주면 좋다.
